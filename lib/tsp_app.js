// the nodes are stated here
let places = [
    "Wellington, Nový Zéland",
    "Tawhai Falls, Nový Zéland",
    "Whakapapa ski, Nový Zéland",
    "Mangawhero Falls, Nový Zéland",
    "Mount Victoria, Nový Zéland",
    "Huka Falls, Nový Zéland",
    "Putangirua Pinnacles, Nový Zéland",
    "Dawson Falls, Nový Zéland",
    "New Plymouth, Nový Zéland",
    "Rainbow Crater, Nový Zéland",
    "Hahei, Nový Zéland",

]//.map(el => el + ", Nový Zéland")

class TspApp {

    constructor() {
        // create the map
        let center = SMap.Coords.fromWGS84(177, -40)
        this.m = new SMap(JAK.gel("m"), center)
        this.m.addDefaultLayer(SMap.DEF_BASE).enable()
        this.m.addDefaultControls()

        // marker layer
        this.marker_layer = new SMap.Layer.Marker()
        this.m.addLayer(this.marker_layer)
        this.marker_layer.enable()

        // geometry layer
        this.geometry_layer = new SMap.Layer.Geometry();
        this.m.addLayer(this.geometry_layer).enable();



        // build all_places from cache
        /** @type {Place[]} */
        this.all_places = places.map(place_name => new Place(place_name))
        Place.assure_all_coord(this.all_places)
        console.log("Coords assured, displaying markers.")
        this.display_markers()

        console.info("Tutorial: Hardcode places. Call `start`. Results are automatically cache to localStorage. Call `generate_matrix_length`. Go to Python to solve TSP. Call `display_route()`. ")
    }

    /**
     * Call each other place and count the length in between.
     * */
    async start() {
        for (const place of this.all_places) {
            for (const p of this.all_places.filter(p => p !== place)) {
                // XX if wanted to increase the performance,
                // we may launch around 6 API call instead of waiting
                // till the single one ends
                await place.compute_distance(p, this)
            }
        }
        this.geometry_layer.clear() // routes might have been cast to the map
        console.info("Start finished. Continue with `generate_matrix_length`.")
    }



    generate_matrix_time() {
        return this._generate_matrix("time")
    }
    generate_matrix_length() {
        return this._generate_matrix("length", ((x) => Math.round(x / 1000)))
    }


    run(matrix) {
        const { bare, places } = this.transform_matrix(matrix)
        const solution = TSP(bare).map(n => places[n])
        console.log(solution)
        this.display_route(solution)
    }

    /**
     * Takes matrix generated by generate_matrix_length, replaces 0 with Infinity and removes cities
     * @param {number[][]} matrix
     */
    transform_matrix(matrix) {
        return { "bare": matrix.slice(1).map(row => row.slice(1).map(val => val === 0 ? Infinity : val)), "places": matrix[0].slice(1) }
    }

    _generate_matrix(pivot, callback = null) {
        const lines = []
        lines.push([""].concat(this.all_places.map(place => place.name)))
        for (const place1 of this.all_places) {
            const line = [place1.name]
            for (const place2 of this.all_places) {
                try {
                    let val = (place1 == place2) ? 0 : place1.distances[place2.name][pivot]
                    if (callback) {
                        val = callback(val)
                    }
                    line.push(val)
                } catch (e) {
                    console.warn("Value not found", "place1", place1.name, "place2", place2.name, "wanted", pivot)
                }
            }
            lines.push(line)
        }

        return lines
    }

    _names_to_places(names = null) {
        const places = names ? (names.map(name => this.all_places.find(p => p.name == name))) : this.all_places
        console.log("Displaying route", places)
        return places
    }


    _show_route_on_map(route) {
        var coords = route.getResults().geometry
        // m.setCenterZoom(...m.computeCenterZoom(coords))
        var g = new SMap.Geometry(SMap.GEOMETRY_POLYLINE, null, coords)
        this.geometry_layer.clear()
        this.geometry_layer.addGeometry(g)
    }

    /*
    *
    * In new window, open route through all places in `all_places`.
    * names - optional list of strings, use places in order of their names.
    */
    async display_route(names = null) {
        const nalezeno = route => {
            if (route._results.error) {
                console.log("***Cannot find route", route)
                return
            }
            console.log("Route", route)
            this._show_route_on_map(route)
            window.open(route._results.url)
        }

        const places = this._names_to_places(names)
        const route = SMap.Route.route(places.map(place => place.coord()), {
            geometry: true
        }).then(nalezeno)
    }

    async display_markers(names = null) {
        const places = this._names_to_places(names)
        places.forEach(place => {

            var card = new SMap.Card();
            card.getHeader().innerHTML = "<strong>Nadpis</strong>";
            card.getBody().innerHTML = "Ahoj, já jsem <em>obsah vizitky</em>!";

            // const znacka = JAK.mel("div");
            // const popisek = JAK.mel("div", { }, {position:"absolute", left:"0px", top:"2px", textAlign:"center", width:"22px", color:"white", fontWeight:"bold"});
            // popisek.innerHTML = this.name;
            // znacka.appendChild(popisek);

            const marker = new SMap.Marker(place.coord(), place.name, {
                title: place.name,
                // url: znacka
            });
            marker.decorate(SMap.Marker.Feature.Card, card)
            this.marker_layer.addMarker(marker)
        })

        // centralize the map
        this.m.setCenterZoom(...this.m.computeCenterZoom(places.map(p => p.coord())))
    }
}

var app = new TspApp() // expose